package envelopes;

import waves.Wave.WaveType;
import waves.SawWave;
import waves.SineWave;
import waves.SquareWave;
import waves.TriangleWave;
import waves.Wave;

/**
@author Alexander Johnston 
        Copyright 2019 
        A class for making amplitude oscillators
 */
public class AmplitudeOscillator {

	// The starting frequency of this oscillator
	double startingFrequency;

	// The starting amplitude width of this oscillator
	// This will create a wave that starts with a wave that goes from (-startAmpWidth) to (startAmpWidth)
	public double startingAmplitudeWidth;

	// The ending frequency of this oscillator
	double endingFrequency;

	// The ending amplitude width of this oscillator
	// This will create a wave that starts with a wave that goes from (-endAmpWidth) to (endAmpWidth)
	public double endingAmplitudeWidth;

	// The phase of the wave generated by this class
	double radians;

	/**       Constructs a amplitude oscillator with
	 * @param startingFrequency as the oscillation rate at the start of the oscillator
	 * @param endingFrequency as the oscillation rate at the end of this oscillator
	 * @param startingAmplitudeWidth as the starting amplitude width of this oscillator. This will create a wave that starts with a wave that goes from (-startAmpWidth) to (startAmpWidth)
	 * @param endingAmplitudeWidth as the ending amplitude width of this oscillator. This will create a wave that starts with a wave that goes from (-endAmpWidth) to (endAmpWidth)
	 * @param radians as the phase of the wave generated by this class
	 */
	public AmplitudeOscillator(double startingFrequency, double endingFrequency, double startingAmplitudeWidth, double endingAmplitudeWidth, double radians) {
		this.startingFrequency = startingFrequency;
		this.endingFrequency = endingFrequency;
		this.startingAmplitudeWidth = startingAmplitudeWidth;
		this.endingAmplitudeWidth = endingAmplitudeWidth;
		this.radians = radians;
	}

	/**        Gets an array representing the amplitudes of this oscillator over time
	 * @param  seconds as the time for the oscillator to take
	 * @param  samplesPerSecond as the sample rate
	 * @return an array representing the amplitudes of this oscillator over time
	 */
	public double[] getAmplitudeArray(double seconds, float samplesPerSecond) {
		double[] amplitudeArray = new double[(int) StrictMath.ceil((seconds*samplesPerSecond))];
		double slope = (endingAmplitudeWidth-startingAmplitudeWidth)/amplitudeArray.length;
		for(int i = 0; i < amplitudeArray.length; i++) {
			amplitudeArray[i] = slope*i+startingAmplitudeWidth;
		}
		return amplitudeArray;
	}

	/**        Generates a wave of frequencies with
	 * @param  seconds as the length of the wave in seconds
	 * @param  waveType as the wave type of this oscillator
	 * @param  samplesPerSecond as the sample rate
	 * @return an array with the wave generated
	 */
	public double[] getOscillator(double seconds, WaveType waveType, float samplesPerSecond) {
		
		// Slope of the frequency
		double frequencySlope = (startingFrequency-endingFrequency)/(samplesPerSecond*seconds);
		
		// Slope of the amplitude width
		double amplitudeWidthSlope = (startingAmplitudeWidth-endingAmplitudeWidth)/(samplesPerSecond*seconds);
		
		double radians = this.radians;
		double wave[] = new double[(int) (seconds*samplesPerSecond)];
		double[] temp; 
		Wave waveObject = null;
		for(int i = 0; i < wave.length-1; i++) {
			switch(waveType) {
			case SINE: 
				waveObject = new SineWave((startingAmplitudeWidth-(amplitudeWidthSlope*i)), ((startingFrequency-(frequencySlope*(i)))), radians);
				break;
			case TRIANGLE: 
				waveObject = new TriangleWave((startingAmplitudeWidth-(amplitudeWidthSlope*i)), ((startingFrequency-(frequencySlope*(i)))), radians);
				break;
			case SAW: 
				waveObject = new SawWave((startingAmplitudeWidth-(amplitudeWidthSlope*i)), ((startingFrequency-(frequencySlope*(i)))), radians);
				break;
			case SQUARE: 
				waveObject = new SquareWave((startingAmplitudeWidth-(amplitudeWidthSlope*i)), ((startingFrequency-(frequencySlope*(i)))), radians);
				break;
			default:
				waveObject = new SineWave((startingAmplitudeWidth-(amplitudeWidthSlope*i)), ((startingFrequency-(frequencySlope*(i)))), radians);
				break;
			}
			temp = waveObject.getWave(1.0/samplesPerSecond, samplesPerSecond);
			wave[i] = temp[0];
			radians += ((2.0*Math.PI)/((samplesPerSecond/((startingFrequency-(frequencySlope*(i+1))))))); 
		}
		switch(waveType) {
		case SINE: 
			waveObject = new SineWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length-1)), ((startingFrequency-(frequencySlope*(wave.length-1)))), radians);
			break;
		case TRIANGLE: 
			waveObject = new TriangleWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length-1)), ((startingFrequency-(frequencySlope*(wave.length-1)))), radians);
			break;
		case SAW: 
			waveObject = new SawWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length-1)), ((startingFrequency-(frequencySlope*(wave.length-1)))), radians);
			break;
		case SQUARE: 
			waveObject = new SquareWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length-1)), ((startingFrequency-(frequencySlope*(wave.length-1)))), radians);
			break;
		default:
			waveObject = new SineWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length-1)), ((startingFrequency-(frequencySlope*(wave.length-1)))), radians);
			break;
		}
		temp = waveObject.getWave(1.0/samplesPerSecond, samplesPerSecond);
		wave[wave.length-1] = temp[0];
		return wave;
	}

	/**        Creates an array with this oscillator combined with an AmplitudeEnvelope
	 * @param  linearAmplitudeEnvelope as the AmplitudeEnvelope to create the base of this oscillator
	 * @param  waveType as the waveType of this oscillator
	 * @param  samplesPerSecond as the sample rate
	 * @return an array with the wave generated WARNING will be null if a waveType has not been specified
	 */
	public double[] getSample(LinearAmplitudeEnvelope linearAmplitudeEnvelope, WaveType waveType, float samplesPerSecond) {
		LinearAmplitudeEnvelope linearAmplitudeEnvelope2 = linearAmplitudeEnvelope;
		linearAmplitudeEnvelope2.addAmplitudeOscillator(this, waveType, samplesPerSecond);
		double[] wave = (linearAmplitudeEnvelope2.getEnvelope());
		return wave;
	}
}
