package envelopes;

import java.util.Objects;

import waves.NoiseWave;
import waves.SawWave;
import waves.SineWave;
import waves.SquareWave;
import waves.TriangleWave;
import waves.Wave;

/**
 * @author Alexander Johnston 
 * @since  2019 
 *         A class for making amplitude oscillators
 */
public class AmplitudeOscillator {

	public enum WaveType {
		SINE, NOISE, TRIANGLE, SQUARE, SAW
	}

	// The starting frequency of this oscillator
	double startingFrequency;

	// The starting amplitude width of this oscillator
	// This will create a wave that starts with a wave that goes from (-startAmpWidth) to (startAmpWidth)
	public double startingAmplitudeWidth;

	// The ending frequency of this oscillator
	double endingFrequency;

	// The ending amplitude width of this oscillator
	// This will create a wave that starts with a wave that goes from (-endAmpWidth) to (endAmpWidth)
	public double endingAmplitudeWidth;

	// The phase of the wave generated by this class
	double radians;

	/**       Constructs an amplitude oscillator.
	 * @param startingFrequency as the oscillation rate at the start of the oscillator
	 * @param endingFrequency as the oscillation rate at the end of this oscillator
	 * @param startingAmplitudeWidth as the starting amplitude width of this oscillator. This will create a wave that starts with a wave that goes from (-startAmpWidth) to (startAmpWidth)
	 * @param endingAmplitudeWidth as the ending amplitude width of this oscillator. This will create a wave that starts with a wave that goes from (-endAmpWidth) to (endAmpWidth)
	 * @param radians as the phase of the wave generated by this class
	 */
	public AmplitudeOscillator(double startingFrequency, double endingFrequency, 
			double startingAmplitudeWidth, double endingAmplitudeWidth, double radians) {
		this.startingFrequency = startingFrequency;
		this.endingFrequency = endingFrequency;
		this.startingAmplitudeWidth = startingAmplitudeWidth;
		this.endingAmplitudeWidth = endingAmplitudeWidth;
		this.radians = radians;
	}

	/**        Gets an array representing the amplitudes of this oscillator over time.
	 * @param  seconds as the time for the oscillator to take
	 * @param  samplesPerSecond as the sample rate
	 * @return an array representing the amplitudes of this oscillator over time
	 * @throws IllegalArgumentException if samplesPerSecond is less than 1, or seconds is less than 0
	 */	
	public double[] getAmplitudeArray(double seconds, float samplesPerSecond) {
		if(seconds < 0) {
			throw new IllegalArgumentException("seconds passed to getAmplitudeArray() must be at least 0");
		}
		if(samplesPerSecond < 1) {
			throw new IllegalArgumentException("samplesPerSecond passed to getAmplitudeArray() must be greater than 0");	
		}
		// Invariants secured

		double[] amplitudeArray = new double[(int) StrictMath.round((seconds*samplesPerSecond))];
		double slope = (endingAmplitudeWidth-startingAmplitudeWidth)/amplitudeArray.length;
		for(int i = 0; i < amplitudeArray.length; i++) {
			amplitudeArray[i] = slope*i+startingAmplitudeWidth;
		}
		return amplitudeArray;
	}

	/**        Generates a wave with frequency and amplitude slopes.
	 * @param  seconds as the length of the wave in seconds
	 * @param  waveType as the wave type of this oscillator
	 * @param  samplesPerSecond as the sample rate
	 * @return an array with the wave generated
	 * @throws IllegalArgumentException if samplesPerSecond is less than 1, or seconds is less than 0
	 */	
	public double[] getOscillator(double seconds, WaveType waveType, float samplesPerSecond) {
		if(seconds < 0) {
			throw new IllegalArgumentException("seconds passed to getOscillator() must be at least 0");
		}
		if(samplesPerSecond < 1) {
			throw new IllegalArgumentException("samplesPerSecond passed to getOscillator() must be greater than 0");	
		}
		if(waveType == null) {
			System.out.println("waveType passed to getOscillator() is null. Defaulting to SINE.");
		}
		// Invariants secured

		// Slope of the frequency
		double frequencySlope = (startingFrequency-endingFrequency)/(samplesPerSecond*seconds);

		// Slope of the amplitude width
		double amplitudeWidthSlope = (startingAmplitudeWidth-endingAmplitudeWidth)/(samplesPerSecond*seconds);

		double radians = this.radians;
		boolean updateRadians = true;
		double wave[] = new double[(int) Math.round((seconds*samplesPerSecond))];
		double[] temp; 
		Wave waveObject = null;
		for(int i = 0; i < wave.length-1; i++) {
			switch(waveType) {
			case SINE: 
				waveObject = new SineWave((startingAmplitudeWidth-(amplitudeWidthSlope*i))
						, ((startingFrequency-(frequencySlope*(i)))), radians, updateRadians);
				break;
			case TRIANGLE: 
				waveObject = new TriangleWave((startingAmplitudeWidth-(amplitudeWidthSlope*i))
						, ((startingFrequency-(frequencySlope*(i)))), radians, updateRadians);
				break;
			case SAW: 
				waveObject = new SawWave((startingAmplitudeWidth-(amplitudeWidthSlope*i))
						, ((startingFrequency-(frequencySlope*(i)))), radians, updateRadians);
				break;
			case SQUARE: 
				waveObject = new SquareWave((startingAmplitudeWidth-(amplitudeWidthSlope*i))
						, ((startingFrequency-(frequencySlope*(i)))), radians, updateRadians);
				break;
			case NOISE:
				waveObject = new NoiseWave((startingAmplitudeWidth-(amplitudeWidthSlope*i)));
				break;
			default:
				waveObject = new SineWave((startingAmplitudeWidth-(amplitudeWidthSlope*i))
						, ((startingFrequency-(frequencySlope*(i)))), radians, updateRadians);
				break;
			}
			temp = waveObject.getWave(1.0/samplesPerSecond, samplesPerSecond);
			wave[i] = temp[0];
			radians += ((2.0*Math.PI)/((samplesPerSecond/((startingFrequency-(frequencySlope*(i+1))))))); 
		}
		switch(waveType) {
		case SINE: 
			waveObject = new SineWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length))
					, ((startingFrequency-(frequencySlope*(wave.length)))), radians, updateRadians);
			break;
		case TRIANGLE: 
			waveObject = new TriangleWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length))
					, ((startingFrequency-(frequencySlope*(wave.length)))), radians, updateRadians);
			break;
		case SAW: 
			waveObject = new SawWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length))
					, ((startingFrequency-(frequencySlope*(wave.length)))), radians, updateRadians);
			break;
		case SQUARE: 
			waveObject = new SquareWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length))
					, ((startingFrequency-(frequencySlope*(wave.length)))), radians, updateRadians);
			break;
		case NOISE:
			waveObject = new NoiseWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length)));
			break;
		default:
			waveObject = new SineWave((startingAmplitudeWidth-(amplitudeWidthSlope*wave.length))
					, ((startingFrequency-(frequencySlope*(wave.length)))), radians, updateRadians);
			break;
		}
		temp = waveObject.getWave(1.0/samplesPerSecond, samplesPerSecond);
		wave[wave.length-1] = temp[0];
		return wave;
	}

	/**        Creates an array with this oscillator combined with an AmplitudeEnvelope.
	 * @param  linearAmplitudeEnvelope as the AmplitudeEnvelope to create the base of this oscillator
	 * @param  waveType as the waveType of this oscillator
	 * @param  samplesPerSecond as the sample rate
	 * @return an array with the wave generated
	 * @throws NullPointerException if linearAmplitudeEnvelope is null.
	 * @throws IllegalArgumentException if samplesPerSecond is less than 1
	 */
	public double[] getSample(LinearAmplitudeEnvelope linearAmplitudeEnvelope, 
			WaveType waveType, float samplesPerSecond) {
		Objects.requireNonNull(linearAmplitudeEnvelope);
		if(samplesPerSecond < 1) {
			throw new IllegalArgumentException("samplesPerSecond passed to getSample() must be greater than 0");	
		}
		if(waveType == null) {
			System.out.println("waveType passed to getSample() is null. Defaulting to SINE.");
		}
		// Invariants secured

		LinearAmplitudeEnvelope linearAmplitudeEnvelope2 = linearAmplitudeEnvelope;
		linearAmplitudeEnvelope2.addAmplitudeOscillator(this, waveType, samplesPerSecond);
		double[] wave = (linearAmplitudeEnvelope2.getEnvelope());
		return wave;
	}
}
